import axios from 'axios';
import configurations from '../configurations';
import * as _ from 'lodash';
import * as Joi from '@hapi/joi';
import 'joi-extract-type';
import { isAxiosError } from './axios-helper';
import logger from './logger';
import WrappedError from '../exceptions/wrapped-error';
import { OpenLabRedirectInfo } from '../features/courses/course-types';
import * as qs from 'qs';
import formHelper, { unmergeStrategies } from './form-helper';
import RederlyError from '../exceptions/rederly-error';

/* eslint-disable @typescript-eslint/camelcase */
export const openlabResponseValidationScheme = Joi.string().required();
/* eslint-enable @typescript-eslint/camelcase */
export type OpenLabResponse = Joi.extractType<typeof openlabResponseValidationScheme>;

class OpenLabHelper {
    openLabAxios = axios.create({
        baseURL: configurations.openlab.url,
        responseType: 'text',
        timeout: configurations.openlab.requestTimeout,
    });

    OPENLAB_QS = qs.stringify({ webwork: 1 });

    /**
     * This function calls OpenLab with sensitive data and returns the js redirect script
     * @param {object} OpenLabRedirectInfo generated by courseController.prepareOpenLabRedirect()
     * @returns {string} a js script that will redirect the user to OpenLab
     */
    async askForHelp({
        problem,
        problemSetId,
        courseId,
        problemPath,
        email,
        studentName,
        emailURL,
        rawHTML,
    }: OpenLabRedirectInfo): Promise<OpenLabResponse> {
        let pgObject = '';
        if (!_.isNil(rawHTML)) {
            pgObject = Buffer.from(rawHTML).toString('base64');
        } else {
            // die -- we must have the renderedHTML for OpenLab
            // and we don't have any anonymous ways of id-ing the users involved...
            logger.error(`OpenLab query requested for ${problemPath} by a student in ${courseId}`);
            throw new RederlyError('Request to OpenLab came back empty');
        }
        const params = {
            problem,
            problemSetId,
            courseId,
            problemPath,
            email,
            studentName,
            emailURL,
            pgObject,
        };

        const resultFormData = formHelper.objectToFormData({object: params, unmerge: unmergeStrategies.unmergeUniqueKeysByIndex});

        try {
            const resp = await this.openLabAxios.post(`?${this.OPENLAB_QS}`, resultFormData?.getBuffer(), {
                headers: resultFormData?.getHeaders()
            });

            return resp.data;
        } catch (e) {
            const errorMessagePrefix = 'OpenLab request failed';
            if(isAxiosError(e)) {
                throw new RederlyError(`${errorMessagePrefix}; response: ${e.response?.data}`, e);
            }
            // Some application error occurred
            throw new WrappedError(errorMessagePrefix, e);
        }
    }
}

const openLabHelper = new OpenLabHelper();
export default openLabHelper;
